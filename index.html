<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <meta name="theme-color" content="#f8faff"/>
  <title>ScorProf — Montée/Descente</title>
  <style>
    :root{
      --bg:#f7f9ff;
      --surface:#ffffff;
      --surface2:#f1f4ff;
      --txt:#0b1b38;
      --muted:#5b6687;
      --accent:#3c6df0;
      --accent2:#1eb980;
      --danger:#ef4444;
      --stroke: rgba(16,52,96,.12);
      --stroke2: rgba(16,52,96,.18);
      --radius: 18px;
      --tap: 46px;
      --shadow: 0 16px 36px rgba(15,40,90,.10);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      --sans: ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:var(--sans);
      background: linear-gradient(180deg, #ffffff, #f7f9ff 60%, #eaf0ff);
      color:var(--txt);
      -webkit-font-smoothing:antialiased;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .app{max-width:1100px;margin:0 auto;padding:16px 16px 90px}
    header{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:10px 6px 16px;
    }
    .brand{display:flex; flex-direction:column; gap:4px}
    .brand .title{font-size:22px;font-weight:900}
    .brand .sub{color:var(--muted); font-size:13px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#fff;
      border:1px solid var(--stroke);
      padding:8px 12px; border-radius:999px;
      box-shadow: var(--shadow);
    }
    .grid{display:grid; gap:14px}
    @media(min-width:980px){ .grid.cols2{grid-template-columns:1.2fr .8fr} }
    .hero{display:flex;align-items:center;justify-content:center;min-height:60vh;text-align:center}
    .heroBox{
      background:#fff;
      border:1px solid var(--stroke);
      border-radius:24px;
      padding:40px 32px;
      box-shadow:var(--shadow);
      max-width:420px;width:100%;
    }
    .heroBox .title{font-size:32px;font-weight:900;margin-bottom:8px}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.98), rgba(255,255,255,.93));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      border-bottom:1px solid rgba(16,52,96,.08);
      background:linear-gradient(180deg, var(--surface2), var(--surface));
    }
    .card .bd{padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row.nowrap{flex-wrap:nowrap}
    .spacer{flex:1}
    .muted{color:var(--muted)}
    .btn{
      min-height:var(--tap);
      padding:10px 14px;
      border-radius:14px;
      border:1px solid rgba(16,52,96,.15);
      background:#fff;
      color:var(--txt);
      font-weight:800;
      cursor:pointer;
      box-shadow:0 8px 18px rgba(15,40,90,.12);
    }
    .btn.primary{background:linear-gradient(135deg, rgba(60,109,240,.18), rgba(60,109,240,.08));border-color:rgba(60,109,240,.32);color:#12306a}
    .btn.good{background:linear-gradient(135deg, rgba(30,185,128,.22), rgba(30,185,128,.08));border-color:rgba(30,185,128,.30);color:#063623}
    .btn.danger{background:linear-gradient(135deg, rgba(239,68,68,.22), rgba(239,68,68,.08));border-color:rgba(239,68,68,.32);color:#5e1010}
    label{display:block;font-size:13px;color:var(--muted);margin:10px 0 6px}
    textarea,input,select{
      width:100%; min-height:44px;
      border-radius:14px;
      border:1px solid var(--stroke2);
      background:#fff;
      color:var(--txt);
      padding:10px 12px;
      font-size:15px;
      outline:none;
    }
    textarea{min-height:160px;resize:vertical;line-height:1.35}
    .hint{font-size:12px;color:var(--muted);margin-top:6px}
    .mini{font-size:12px;color:var(--muted);line-height:1.35}
    .courtList{display:grid;gap:10px}
    .court{
      background:rgba(255,255,255,.95);
      border:1px solid rgba(16,52,96,.10);
      border-radius:16px;
      padding:12px;
      display:flex;flex-direction:column;gap:10px;
      box-shadow:0 10px 24px rgba(15,40,90,.08);
    }
    .modal .court.modalMatch{
      background:#fff;
      border:1px solid var(--stroke);
      color:var(--txt);
      box-shadow:none;
    }
    .courtTop{display:flex;align-items:center;gap:10px}
    .courtTop .name{font-weight:900}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid rgba(16,52,96,.15);background:rgba(60,109,240,.08);color:var(--muted)}
    .tag.arbTag{background:rgba(255,214,102,.25);border-color:rgba(255,214,102,.5);color:#7a4a00;font-weight:700}
    .switch{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(16,52,96,.12);background:rgba(247,249,255,.9)}
    .switch input{width:22px;height:22px}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:520px){.two{grid-template-columns:1fr}}
    .teamsRow{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:520px){.teamsRow{grid-template-columns:1fr}}
    .teamScore{border:1px solid rgba(16,52,96,.12);border-radius:14px;padding:10px 12px;background:#f6f8ff}
    .teamScore .teamLabel{font-weight:900;margin-bottom:4px}
    .teamScore .playerName{font-size:14px;color:var(--txt);line-height:1.35}
    .teamScore input{width:100%;margin-top:8px;text-align:center;font-family:var(--mono);font-weight:900;font-size:18px;border:1px solid rgba(16,52,96,.25);border-radius:12px;padding:8px}
    .warnBox{font-size:13px;padding:10px 12px;border-radius:12px;background:rgba(239,68,68,.12);border:1px solid rgba(239,68,68,.3);color:#8c1515}
    .table{width:100%;border-collapse:separate;border-spacing:0;border:1px solid var(--stroke);border-radius:18px;overflow:hidden}
    .table th,.table td{padding:10px 12px;text-align:left;font-size:13px}
    .table th{background:var(--surface2);color:var(--txt);font-weight:800}
    .table td{background:var(--surface);color:var(--txt)}
    .table tr:nth-child(even) td{background:var(--surface2)}
    .nav{position:fixed;left:0;right:0;bottom:0;padding:10px 14px calc(10px + env(safe-area-inset-bottom));background:rgba(255,255,255,.92);backdrop-filter:blur(14px);border-top:1px solid rgba(16,52,96,.12);box-shadow:0 -12px 30px rgba(15,40,90,.12)}
    .navInner{max-width:1100px;margin:0 auto;display:flex;gap:10px;justify-content:space-between}
    .navBtn{flex:1;min-height:50px;border-radius:16px;border:1px solid rgba(16,52,96,.12);background:rgba(255,255,255,.95);color:var(--muted);font-weight:900;cursor:pointer}
    .navBtn.active{background:rgba(60,109,240,.14);border-color:rgba(60,109,240,.28);color:#12306a;box-shadow:0 10px 20px rgba(60,109,240,.25)}
    .modal{position:fixed;inset:0;display:none;background:rgba(0,0,0,.55);padding:14px;z-index:50}
    .modal.open{display:flex;align-items:flex-end}
    .modal.timerCenter{align-items:center;justify-content:center}
    @media(min-width:720px){.modal.open{align-items:center;justify-content:center}}
    .sheet{width:100%;max-width:860px;background:linear-gradient(180deg, rgba(18,27,46,.98), rgba(12,18,32,.98));border:1px solid rgba(255,255,255,.12);border-radius:22px;box-shadow:0 30px 90px rgba(0,0,0,.55);overflow:hidden}
    .sheet .hd{padding:14px;display:flex;align-items:center;gap:10px;justify-content:space-between;border-bottom:1px solid rgba(255,255,255,.08);color:#fff}
    .sheet .bd{padding:14px;max-height:70vh;overflow:auto;color:#fff}
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:90px;z-index:60;background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.14);color:#fff;padding:10px 14px;border-radius:999px;display:none}
    .toast.show{display:block}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="title">ScorProf</div>
        <div class="sub">Gestion montée/descente — badminton</div>
      </div>
      <div class="pill">
        <span class="muted">Tournoi :</span> <b id="tournamentName">Évaluation Bac</b>
      </div>
    </header>

    <section id="page-home" class="hero">
      <div class="heroBox">
        <div class="title">ScorProf</div>
        <p class="muted">Organise ta séance montée/descente en trois étapes simples.</p>
        <button class="btn primary" id="btnStart">Démarrer</button>
      </div>
    </section>

    <section id="page-setup" style="display:none" class="grid cols2">
      <div class="card">
        <div class="hd">
          <h2>Saisie — classe &amp; configuration</h2>
          <button class="btn primary" id="btnSaveSetup">Enregistrer</button>
        </div>
        <div class="bd">
          <label>Nom de la séance / tournoi</label>
          <input id="inpTournament" placeholder="Ex: Bac badminton — 8 février" />
          <div class="hint">Ce nom apparaît dans l’export CSV.</div>

          <div class="row" style="margin:12px 0">
            <button class="btn danger" id="btnResetAll">Réinitialiser</button>
            <button class="btn" id="btnInstallTip">Astuces iPad</button>
          </div>

          <label style="margin-top:14px">Liste des élèves (1 par ligne)</label>
          <textarea id="taStudents" placeholder="Ex:
Alice
Baptiste
Camille
..."></textarea>
          <div class="hint">Astuce : tu peux coller depuis un tableau ou un document.</div>

          <div class="two" style="margin-top:10px">
            <div>
              <label>Nombre de terrains (1 à 12)</label>
              <input id="inpCourts" type="number" min="1" max="12" value="8"/>
              <div class="hint">Double possible seulement sur les 2 terrains centraux.</div>
            </div>
            <div>
              <label>Nom des 2 terrains centraux</label>
              <input id="inpCenterNames" value="Centre 1, Centre 2"/>
              <div class="hint">Format : “Centre 1, Centre 2”.</div>
            </div>
          </div>

          <label style="margin-top:14px">Règles par terrain</label>
          <div class="hint">Personnalise chaque terrain : simple/double et avec/sans arbitre.</div>
          <div id="courtConfig" class="courtList" style="margin-top:10px"></div>
        </div>
      </div>

      <div class="card">
        <div class="hd"><h2>Outils rapides</h2></div>
        <div class="bd">
          <div class="row">
            <button class="btn" id="btnAutoSingles">Tout en simple</button>
            <button class="btn" id="btnCenterDoubles">Double sur les centraux</button>
          </div>
          <div class="row" style="margin-top:10px">
            <button class="btn" id="btnNoUmpires">Sans arbitre partout</button>
            <button class="btn" id="btnYesUmpires">Avec arbitre partout</button>
          </div>
        </div>
      </div>
    </section>

    <section id="page-assign" style="display:none" class="grid cols2">
      <div class="card">
        <div class="hd">
          <h2>Répartition — montée/descente</h2>
          <div class="row">
            <button class="btn" id="btnAutoAssign">Remplir auto</button>
            <button class="btn primary" id="btnSaveAssignments">Enregistrer</button>
          </div>
        </div>
        <div class="bd">
          <div class="muted" style="margin-bottom:10px">Affecte les élèves aux terrains. Les arbitres sont mémorisés si activés.</div>
          <div id="assignCourts" class="courtList"></div>
        </div>
      </div>

      <div class="card">
        <div class="hd"><h2>Élèves en attente</h2></div>
        <div class="bd">
          <div class="muted" id="assignPool">Configure d’abord la classe pour utiliser la répartition.</div>
        </div>
      </div>
    </section>

    <section id="page-matches" style="display:none">
      <div class="card">
        <div class="hd">
          <h2>Matchs — saisie des scores</h2>
          <div class="row nowrap">
            <button class="btn danger" id="btnUndoLast">Annuler dernier match</button>
            <button class="btn primary" id="btnSaveMatches">Enregistrer les matchs</button>
            <button class="btn good" id="btnApplyRotation">Rotation suivante</button>
            <button class="btn" id="btnEndSession">Fin de partie</button>
            <button class="btn" id="btnToggleManualEdit">Édition manuelle</button>
          </div>
        </div>
        <div class="bd">
          <div class="row" style="gap:10px; align-items:flex-start; margin-bottom:10px">
            <div class="hint" style="flex:1">
              1) Vérifie les équipes/arbitres depuis <b>Répartition</b>.<br/>
              2) Ici, tu saisis uniquement les scores.<br/>
              3) Clique <b>Enregistrer les matchs</b> puis passe à la rotation suivante.
            </div>
            <button class="btn" id="btnEditAssignments">Modifier la répartition</button>
          </div>

          <div class="card" style="margin-bottom:14px" id="timerCard">
            <div class="hd">
              <h2>Chrono</h2>
              <div class="pill"><span class="muted">Match :</span> <b id="timerDisplay">00:00</b></div>
            </div>
            <div class="bd">
              <div class="two">
                <div>
                  <label>Durée (minutes)</label>
                  <input id="timerMinutes" type="number" min="0" value="5" />
                  <div class="hint">Ex : 4–6 min/match en rotation rapide.</div>
                </div>
                <div>
                  <label>Signal fin</label>
                  <select id="timerBeep">
                    <option value="1">Bip</option>
                    <option value="0">Silencieux</option>
                  </select>
                  <div class="hint">Le bip nécessite un premier clic (iOS).</div>
                </div>
              </div>
              <div class="row" style="margin-top:12px">
                <button class="btn good" id="timerStart">Start</button>
                <button class="btn" id="timerPause">Pause</button>
                <button class="btn" id="timerReset">Reset</button>
                <button class="btn" id="btnTimerPopup">Plein écran</button>
              </div>
            </div>
          </div>

          <button class="btn" id="btnNewRound" style="margin-bottom:10px">Ajouter une rotation manuelle</button>

          <div id="courtsLive" class="courtList"></div>

          <div class="card" id="manualAdjustSection" style="display:none;margin-top:14px">
            <div class="hd">
              <h2>Ajustements manuels</h2>
              <button class="btn primary" id="btnSaveManualAdjust">Enregistrer</button>
            </div>
            <div class="bd">
              <div class="hint">Corrige la rotation directement depuis cette page si besoin.</div>
              <div id="manualAdjust" class="courtList" style="margin-top:10px"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="page-results" style="display:none" class="grid cols2">
      <div class="card">
        <div class="hd">
          <h2>Bilan — classement</h2>
          <div class="row">
            <button class="btn" id="btnExport">Exporter CSV</button>
          </div>
        </div>
        <div class="bd">
          <table class="table" id="tblRanking">
            <thead>
              <tr>
                <th>#</th>
                <th>Élève</th>
                <th>Perf</th>
                <th>Points</th>
                <th>Victoires</th>
                <th>Défaites</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <div class="hint" style="margin-top:10px">
            <b>Indice de performance</b> : inspiré du système ELO (méthode de classement développée pour les échecs qui attribue plus ou moins de points selon la force de l’adversaire affronté).
          </div>
        </div>
      </div>

      <div class="card">
        <div class="hd"><h2>Résumé</h2></div>
        <div class="bd">
          <div class="kpi">
            <div class="box"><div class="v" id="kpiStudents">0</div><div class="l">Élèves</div></div>
            <div class="box"><div class="v" id="kpiMatches">0</div><div class="l">Matchs</div></div>
            <div class="box"><div class="v" id="kpiCourts">0</div><div class="l">Terrains</div></div>
            <div class="box"><div class="v" id="kpiLast">—</div><div class="l">Dernier match</div></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div class="nav">
    <div class="navInner">
      <button class="navBtn active" data-nav="home">Accueil</button>
      <button class="navBtn" data-nav="setup">Saisie</button>
      <button class="navBtn" data-nav="assign">Répartition</button>
      <button class="navBtn" data-nav="matches">Matchs</button>
      <button class="navBtn" data-nav="results">Bilan</button>
    </div>
  </div>

  <div class="modal" id="playerModal" role="dialog" aria-modal="true">
    <div class="sheet">
      <div class="hd">
        <div>
          <div style="font-weight:900" id="pmName">Élève</div>
          <div class="muted" id="pmSub">Détails</div>
        </div>
        <button class="btn" id="pmClose">Fermer</button>
      </div>
      <div class="bd">
        <div class="kpi" style="margin-bottom:12px">
          <div class="box"><div class="v" id="pmPerf">—</div><div class="l">Indice perf</div></div>
          <div class="box"><div class="v" id="pmVD">—</div><div class="l">V-D</div></div>
          <div class="box"><div class="v" id="pmPts">—</div><div class="l">Points +/-</div></div>
          <div class="box"><div class="v" id="pmRate">—</div><div class="l">%</div></div>
        </div>
        <div style="font-weight:900;margin:8px 0">Évolution perf</div>
        <canvas id="pmChart" width="900" height="260" style="max-width:100%;margin-bottom:12px"></canvas>
        <div class="hint" style="margin-bottom:12px">Indice ELO : système de classement utilisé aux échecs, qui ajuste la note selon la force de l’adversaire affronté.</div>
        <div style="font-weight:900;margin:8px 0">Matchs</div>
        <div id="pmMatches"></div>
      </div>
    </div>
  </div>

  <div class="modal timerCenter" id="timerModal" role="dialog" aria-modal="true">
    <div class="sheet" style="max-width:420px">
      <div class="hd">
        <h2>Chrono</h2>
        <button class="btn" id="btnTimerClose">Fermer</button>
      </div>
      <div class="bd" style="text-align:center">
        <div style="font-size:72px;font-family:var(--mono);font-weight:900" id="timerPopupDisplay">00:00</div>
        <button class="btn" id="btnTimerFullscreen">Plein écran</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
const STORE_KEY = "scorprof.v1";

const defaultState = () => ({
  tournamentName: "Évaluation Bac",
  students: [],
  courts: [],
  matches: [],
  assignments: {},
  round: 1
});

let state = loadState();
let setupPreview = [];
let timer = { running:false, endAt:null, remainingMs:0 };
const tournamentNameEl = document.getElementById("tournamentName");

function loadState(){
  try{
    const raw = localStorage.getItem(STORE_KEY);
    if(!raw) return defaultState();
    return Object.assign(defaultState(), JSON.parse(raw));
  }catch(e){
    return defaultState();
  }
}
function saveState(){
  localStorage.setItem(STORE_KEY, JSON.stringify(state));
  renderAll();
}
function toast(msg){
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.classList.add("show");
  setTimeout(()=>el.classList.remove("show"), 1500);
}

function uid(prefix="id"){
  return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}

/** ===== Timer ===== */
const timerDisplay = document.getElementById("timerDisplay");
const timerMinutes = document.getElementById("timerMinutes");
const timerBeep = document.getElementById("timerBeep");
const timerModalEl = document.getElementById("timerModal");
const timerPopupDisplay = document.getElementById("timerPopupDisplay");

function fmtMMSS(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,"0");
  const ss = String(s%60).padStart(2,"0");
  return `${mm}:${ss}`;
}
function renderTimer(){
  const ms = timer.running ? (timer.endAt - Date.now()) : timer.remainingMs;
  timerDisplay.textContent = fmtMMSS(ms);
  timerPopupDisplay.textContent = fmtMMSS(ms);
}
function tick(){
  if(!timer.running) return;
  const left = timer.endAt - Date.now();
  if(left<=0){
    timer.running = false;
    timer.remainingMs = 0;
    renderTimer();
    if(timerBeep.value==="1"){
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine"; osc.frequency.value = 880;
        gain.gain.value = 0.03;
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start();
        setTimeout(()=>{osc.stop();ctx.close();},200);
      }catch(e){}
    }
    toast("Temps écoulé");
    return;
  }
  renderTimer();
  requestAnimationFrame(tick);
}

document.getElementById("timerStart").addEventListener("click", ()=>{
  const mins = Math.max(0, Number(timerMinutes.value||0));
  if(!timer.running){
    if(timer.remainingMs<=0) timer.remainingMs = mins*60000;
    timer.endAt = Date.now() + timer.remainingMs;
    timer.running = true;
    tick();
    timerModalEl.classList.add("open");
  }
});
document.getElementById("timerPause").addEventListener("click", ()=>{
  if(timer.running){
    timer.remainingMs = Math.max(0, timer.endAt - Date.now());
    timer.running = false;
    renderTimer();
  }
});
document.getElementById("timerReset").addEventListener("click", ()=>{
  timer.running = false;
  timer.remainingMs = Math.max(0, Number(timerMinutes.value||0))*60000;
  renderTimer();
});
document.getElementById("btnTimerPopup").addEventListener("click", ()=>{
  timerModalEl.classList.add("open");
});
document.getElementById("btnTimerClose").addEventListener("click", ()=>{
  timerModalEl.classList.remove("open");
});
if(timerModalEl){
  timerModalEl.addEventListener("click", (e)=>{
    if(e.target === timerModalEl){
      timerModalEl.classList.remove("open");
    }
  });
}
document.getElementById("btnTimerFullscreen").addEventListener("click", ()=>{
  const target = timerPopupDisplay;
  if(target.requestFullscreen){
    target.requestFullscreen().catch(()=>{});
  }
});
renderTimer();

/** ===== Setup ===== */
const taStudents = document.getElementById("taStudents");
const inpCourts = document.getElementById("inpCourts");
const inpCenterNames = document.getElementById("inpCenterNames");
const courtConfig = document.getElementById("courtConfig");

function buildCourts(count){
  const n = Math.min(12, Math.max(1, count|0));
  const centers = inpCenterNames.value.split(",").map(s=>s.trim()).filter(Boolean);
  const courts = [];
  const mid = Math.max(0, Math.floor((n-1)/2));
  const second = Math.min(n-1, mid+1);
  for(let i=0;i<n;i++){
    let name = `Terrain ${i+1}`;
    let allowDoubles = false;
    if(n>1 && (i===mid || i===second)){
      allowDoubles = true;
      name = i===mid ? (centers[0] || "Centre 1") : (centers[1] || "Centre 2");
    }
    courts.push({
      id: uid("court"),
      name,
      allowDoubles,
      mode: "S",
      umpire: false
    });
  }
  return courts;
}

function editableCourts(){
  if(state.courts.length) return state.courts;
  if(!setupPreview.length){
    setupPreview = buildCourts(Number(inpCourts.value||8));
  }
  return setupPreview;
}

function renderCourtConfig(){
  const list = editableCourts();
  courtConfig.innerHTML = "";
  list.forEach((court, idx)=>{
    const wrapper = document.createElement("div");
    wrapper.className = "court";
    wrapper.dataset.index = idx;
    wrapper.innerHTML = `
      <div class="courtTop">
        <div class="name">${escapeHtml(court.name)}</div>
        <span class="tag">${court.allowDoubles ? "Double possible" : "Simple uniquement"}</span>
      </div>
      <div class="two">
        <div class="switch">
          <input type="checkbox" data-act="mode" ${court.mode==="D" ? "checked": ""} ${court.allowDoubles ? "" : "disabled"}>
          <div>
            <div style="font-weight:900">Double</div>
            <div class="mini">${court.allowDoubles ? "Active 2 vs 2" : "Interdit"}</div>
          </div>
        </div>
        <div class="switch">
          <input type="checkbox" data-act="umpire" ${court.umpire ? "checked" : ""}>
          <div>
            <div style="font-weight:900">Avec arbitre</div>
            <div class="mini">Gestion du temps / responsabilité</div>
          </div>
        </div>
      </div>
    `;
    wrapper.querySelectorAll("input[type=checkbox]").forEach(cb=>{
      cb.addEventListener("change", (e)=>{
        const targetList = editableCourts();
        const targetCourt = targetList[idx];
        if(!targetCourt) return;
        if(cb.dataset.act==="mode"){
          targetCourt.mode = cb.checked ? "D" : "S";
          if(!targetCourt.allowDoubles) targetCourt.mode = "S";
        }
        if(cb.dataset.act==="umpire"){
          targetCourt.umpire = cb.checked;
        }
        if(targetList === state.courts){
          saveState();
        }
      });
    });
    courtConfig.appendChild(wrapper);
  });
}

function handleSetupSave(){
  const names = taStudents.value.split("\n").map(s=>s.trim()).filter(Boolean);
  if(names.length===0){
    alert("Saisis au moins un élève");
    return;
  }
  const count = Math.min(12, Math.max(1, Number(inpCourts.value||8)));
  let list = editableCourts();
  if(list.length !== count){
    list = buildCourts(count);
  }
  state.students = names.map(n=>({id:uid("student"), name:n}));
  state.courts = list.map(c=>({
    id: c.id || uid("court"),
    name: c.name,
    allowDoubles: c.allowDoubles,
    mode: c.allowDoubles ? c.mode : "S",
    umpire: !!c.umpire
  }));
  setupPreview = [];
  state.assignments = {};
  state.matches = [];
  state.round = 1;
  state.tournamentName = inpTournament.value.trim() || "Évaluation Bac";
  saveState();
  toast("Saisie enregistrée");
  showPage("assign");
}

document.getElementById("btnSaveSetup").addEventListener("click", handleSetupSave);

function applyQuick(fn){
  const list = editableCourts();
  fn(list);
  if(list === state.courts){
    saveState();
  }else{
    renderCourtConfig();
  }
}

document.getElementById("btnAutoSingles").addEventListener("click", ()=>{
  applyQuick(list=>list.forEach(c=>c.mode="S"));
});
document.getElementById("btnCenterDoubles").addEventListener("click", ()=>{
  applyQuick(list=>{
    list.forEach(c=>{
      c.mode = c.allowDoubles ? "D" : "S";
    });
  });
});
document.getElementById("btnNoUmpires").addEventListener("click", ()=>{
  applyQuick(list=>list.forEach(c=>c.umpire=false));
});
document.getElementById("btnYesUmpires").addEventListener("click", ()=>{
  applyQuick(list=>list.forEach(c=>c.umpire=true));
});

inpCourts.addEventListener("change", ()=>{
  if(state.courts.length===0){
    setupPreview = buildCourts(Number(inpCourts.value||8));
    renderCourtConfig();
  }
});
inpCenterNames.addEventListener("change", ()=>{
  if(state.courts.length===0){
    setupPreview = buildCourts(Number(inpCourts.value||8));
    renderCourtConfig();
  }
});

/** ===== Répartition ===== */
const assignCourtsEl = document.getElementById("assignCourts");
const assignPoolEl = document.getElementById("assignPool");
const btnSaveAssignments = document.getElementById("btnSaveAssignments");
const btnAutoAssign = document.getElementById("btnAutoAssign");

function getAssignment(court){
  if(!state.assignments[court.id]){
    state.assignments[court.id] = {teamA:[], teamB:[], umpire:null};
  }
  return state.assignments[court.id];
}

function studentOptionsHTML(selected){
  return state.students.map(s=>`
    <option value="${s.id}" ${s.id===selected ? "selected" : ""}>${escapeHtml(s.name)}</option>
  `).join("");
}

function renderAssignmentCards(container, {showUmpireToggle=false}={}){
  container.innerHTML = "";
  const used = new Set();
  state.courts.forEach((court, idx)=>{
    const assign = getAssignment(court);
    assign.teamA.forEach(id=>used.add(id));
    assign.teamB.forEach(id=>used.add(id));
    if(assign.umpire) used.add(assign.umpire);
    const slots = court.allowDoubles && court.mode==="D" ? 2 : 1;
    const buildTeamSelects = (teamKey, values)=>{
      if(slots===1){
        return `<select data-slot="${teamKey}0" data-court="${court.id}"><option value="">—</option>${studentOptionsHTML(values[0])}</select>`;
      }
      const items = [];
      for(let i=0;i<2;i++){
        items.push(`<select data-slot="${teamKey}${i}" data-court="${court.id}"><option value="">—</option>${studentOptionsHTML(values[i])}</select>`);
      }
      return `<div class="two">${items.join("")}</div>`;
    };
    const umpireBlock = court.umpire ? `<div><label>Arbitre</label><select data-slot="umpire" data-court="${court.id}"><option value="">—</option>${studentOptionsHTML(assign.umpire)}</select></div>` : "";
    const umpireToggle = showUmpireToggle ? `
      <label class="switch" style="max-width:220px;margin-left:auto">
        <input type="checkbox" data-act="toggle-umpire" data-id="${court.id}" ${court.umpire ? "checked":""}>
        <div>
          <div style="font-weight:900">Arbitre requis</div>
          <div class="mini">${court.umpire ? "Un élève arbitrera ce terrain" : "Sans arbitre"}</div>
        </div>
      </label>` : "";
    const block = document.createElement("div");
    block.className = "court";
    block.dataset.court = court.id;
    block.innerHTML = `
      <div class="courtTop">
        <div class="name">${escapeHtml(court.name)}</div>
        <span class="tag">${slots===2 ? "Double" : "Simple"}</span>
        <span class="tag">${court.umpire ? "Avec arbitre" : "Sans arbitre"}</span>
        ${umpireToggle}
      </div>
      <div class="two">
        <div>
          <label>Équipe A</label>
          ${buildTeamSelects("a", assign.teamA)}
        </div>
        <div>
          <label>Équipe B</label>
          ${buildTeamSelects("b", assign.teamB)}
        </div>
      </div>
      ${umpireBlock}
    `;
    container.appendChild(block);
  });
  if(showUmpireToggle){
    container.querySelectorAll("[data-act=toggle-umpire]").forEach(cb=>{
      cb.addEventListener("change", ()=>{
        const id = cb.dataset.id;
        const court = state.courts.find(x=>x.id===id);
        if(!court) return;
        court.umpire = !!cb.checked;
        if(!court.umpire && state.assignments[court.id]){
          state.assignments[court.id].umpire = null;
        }
        saveState();
      });
    });
  }
  attachAssignmentSelectHandlers(container);
  return used;
}

function renderAssignmentsPage(){
  if(!assignCourtsEl) return;
  assignCourtsEl.innerHTML = "";
  if(state.students.length===0 || state.courts.length===0){
    assignCourtsEl.innerHTML = `<div class="muted">Commence par saisir la classe et configurer les terrains.</div>`;
    if(assignPoolEl) assignPoolEl.textContent = "—";
    return;
  }
  const used = renderAssignmentCards(assignCourtsEl, {showUmpireToggle:true});
  if(assignPoolEl){
    const waiting = state.students.filter(s=>!used.has(s.id));
    assignPoolEl.textContent = waiting.length ? waiting.map(s=>s.name).join(", ") : "Tous les élèves sont affectés.";
  }
}

function attachAssignmentSelectHandlers(root){
  const selects = root.querySelectorAll("select[data-slot]");
  selects.forEach(sel=>{
    sel.addEventListener("change", ()=>refreshAssignmentSelectOptions(root));
  });
  refreshAssignmentSelectOptions(root);
}

function refreshAssignmentSelectOptions(root){
  const selects = Array.from(root.querySelectorAll("select[data-slot]"));
  const currentValues = selects.map(sel=>sel.value);
  selects.forEach((sel, idx)=>{
    const selected = sel.value;
    const usedElsewhere = new Set();
    currentValues.forEach((val, j)=>{
      if(val && j!==idx) usedElsewhere.add(val);
    });
    const options = state.students.filter(s=>!usedElsewhere.has(s.id) || s.id===selected);
    const html = ['<option value="">—</option>'];
    options.forEach(s=>{
      html.push(`<option value="${s.id}" ${s.id===selected ? "selected":""}>${escapeHtml(s.name)}</option>`);
    });
    sel.innerHTML = html.join("");
    sel.value = selected;
  });
}

function collectAssignmentsFromContainer(container){
  const next = {};
  const used = new Set();
  for(const court of state.courts){
    const card = container.querySelector(`[data-court="${court.id}"]`);
    if(!card) {
      next[court.id] = getAssignment(court);
      continue;
    }
    const slots = court.allowDoubles && court.mode==="D" ? 2 : 1;
    const teamA = [];
    const teamB = [];
    for(let i=0;i<slots;i++){
      const va = card.querySelector(`[data-slot="a${i}"]`)?.value || "";
      const vb = card.querySelector(`[data-slot="b${i}"]`)?.value || "";
      if(va){
        if(used.has(va)){
          alert("Un élève apparaît plusieurs fois.");
          return null;
        }
        used.add(va);
        teamA.push(va);
      }
      if(vb){
        if(used.has(vb)){
          alert("Un élève apparaît plusieurs fois.");
          return null;
        }
        used.add(vb);
        teamB.push(vb);
      }
    }
    let umpire = null;
    if(court.umpire){
      const vu = card.querySelector(`[data-slot="umpire"]`)?.value || "";
      if(vu){
        if(used.has(vu)){
          alert("Un élève apparaît plusieurs fois.");
          return null;
        }
        used.add(vu);
        umpire = vu;
      }
    }
    next[court.id] = {teamA, teamB, umpire};
  }
  return next;
}

btnSaveAssignments.addEventListener("click", ()=>{
  if(state.students.length===0 || state.courts.length===0){
    alert("Configure d’abord Saisie");
    return;
  }
  const result = collectAssignmentsFromContainer(assignCourtsEl);
  if(!result) return;
  state.assignments = result;
  saveState();
  toast("Répartition enregistrée");
});

btnAutoAssign.addEventListener("click", ()=>{
  if(state.students.length===0 || state.courts.length===0){
    alert("Saisis d’abord la classe");
    return;
  }
  const ids = [...state.students.map(s=>s.id)];
  let cursor = 0;
  const next = {};
  state.courts.forEach(court=>{
    const slots = court.allowDoubles && court.mode==="D" ? 2 : 1;
    const total = slots*2;
    const slice = ids.slice(cursor, cursor+total);
    cursor += total;
    next[court.id] = {
      teamA: slice.slice(0, slots),
      teamB: slice.slice(slots, total),
      umpire: court.umpire ? ids[cursor++] || null : null
    };
  });
  state.assignments = next;
  saveState();
  renderAssignmentsPage();
  toast("Répartition auto effectuée");
});

/** ===== Matchs ===== */
const courtsLive = document.getElementById("courtsLive");
const btnSaveMatches = document.getElementById("btnSaveMatches");
const btnEndSession = document.getElementById("btnEndSession");
const btnEditAssignments = document.getElementById("btnEditAssignments");
const btnApplyRotation = document.getElementById("btnApplyRotation");
const btnNewRound = document.getElementById("btnNewRound");
const btnUndoLast = document.getElementById("btnUndoLast");
const manualAdjustWrap = document.getElementById("manualAdjustSection");
const manualAdjustList = document.getElementById("manualAdjust");
const btnToggleManualEdit = document.getElementById("btnToggleManualEdit");
const btnSaveManualAdjust = document.getElementById("btnSaveManualAdjust");
let manualEditVisible = false;

function studentNameById(id){
  if(!id) return "";
  return state.students.find(s=>s.id===id)?.name || "";
}

function renderCourtsLive(){
  courtsLive.innerHTML = "";
  if(state.students.length===0 || state.courts.length===0){
    courtsLive.innerHTML = `<div class="muted">Configure la séance avant d’enregistrer les scores.</div>`;
    return;
  }
  state.courts.forEach(court=>{
    const card = document.createElement("div");
    card.className = "court";
    card.dataset.court = court.id;
    const assign = getAssignment(court);
    const slots = court.allowDoubles && court.mode==="D" ? 2 : 1;
    const namesA = assign.teamA.map(studentNameById);
    const namesB = assign.teamB.map(studentNameById);
    card.innerHTML = `
      <div class="courtTop">
        <div class="name">${escapeHtml(court.name)}</div>
        <span class="tag">${slots===2 ? "Double" : "Simple"}</span>
        <span class="tag">${court.umpire ? "Avec arbitre" : "Sans arbitre"}</span>
        ${court.umpire ? `<span class="tag arbTag">Arbitre : <span class="arbName">${escapeHtml(studentNameById(assign.umpire) || "—")}</span></span>` : ""}
        <span class="tag">Rotation ${state.round}</span>
      </div>
      <div class="teamsRow">
        <div class="teamScore">
          <div class="teamLabel">Équipe A</div>
          ${(namesA.length ? namesA : ["À définir"]).map(n=>`<div class="playerName">${escapeHtml(n)}</div>`).join("")}
          <input type="number" min="0" inputmode="numeric" placeholder="Score A" data-role="scoreA" data-court="${court.id}">
        </div>
        <div class="teamScore">
          <div class="teamLabel">Équipe B</div>
          ${(namesB.length ? namesB : ["À définir"]).map(n=>`<div class="playerName">${escapeHtml(n)}</div>`).join("")}
          <input type="number" min="0" inputmode="numeric" placeholder="Score B" data-role="scoreB" data-court="${court.id}">
        </div>
      </div>
      ${assign.teamA.length===slots && assign.teamB.length===slots ? "" : `<div class='warnBox'>Affecte deux équipes complètes pour ce terrain.</div>`}
    `;
    courtsLive.appendChild(card);
  });
}

function renderManualAdjust(){
  if(!manualAdjustWrap || !manualAdjustList){
    return;
  }
  manualAdjustWrap.style.display = manualEditVisible ? "" : "none";
  if(btnToggleManualEdit){
    btnToggleManualEdit.textContent = manualEditVisible ? "Masquer édition" : "Édition manuelle";
  }
  if(!manualEditVisible) return;
  if(state.students.length===0 || state.courts.length===0){
    manualAdjustList.innerHTML = `<div class="muted">Configure la séance avant d’éditer.</div>`;
    return;
  }
  renderAssignmentCards(manualAdjustList, {showUmpireToggle:true});
}

function collectMatchData(court, card){
  const scoreA = Number(card.querySelector(`[data-role="scoreA"][data-court="${court.id}"]`)?.value || "");
  const scoreB = Number(card.querySelector(`[data-role="scoreB"][data-court="${court.id}"]`)?.value || "");
  if(!Number.isFinite(scoreA) || !Number.isFinite(scoreB)){
    throw new Error(`Scores invalides sur ${court.name}`);
  }
  const assign = getAssignment(court);
  const slots = court.allowDoubles && court.mode==="D" ? 2 : 1;
  if(assign.teamA.length !== slots || assign.teamB.length !== slots){
    throw new Error(`Répartition incomplète sur ${court.name}`);
  }
  return {teamA:[...assign.teamA], teamB:[...assign.teamB], scoreA:scoreA|0, scoreB:scoreB|0, umpire:assign.umpire};
}

btnSaveMatches.addEventListener("click", ()=>{
  if(state.courts.length===0){
    alert("Aucun terrain configuré");
    return;
  }
  const payloads = [];
  try{
    state.courts.forEach(court=>{
      const card = courtsLive.querySelector(`[data-court="${court.id}"]`);
      if(!card) return;
      const scoreA = card.querySelector(`[data-role="scoreA"][data-court="${court.id}"]`)?.value.trim();
      const scoreB = card.querySelector(`[data-role="scoreB"][data-court="${court.id}"]`)?.value.trim();
      if(!scoreA && !scoreB) return;
      payloads.push({court, card, data:collectMatchData(court, card)});
    });
  }catch(err){
    alert(err.message);
    return;
  }
  if(payloads.length===0){
    toast("Aucun score saisi");
    return;
  }
  payloads.forEach(({court, card, data})=>{
    state.matches.push({
      id: uid("m"),
      ts: Date.now(),
      courtId: court.id,
      mode: court.allowDoubles && court.mode==="D" ? "D" : "S",
      umpire: court.umpire,
      teamA: data.teamA,
      teamB: data.teamB,
      scoreA: data.scoreA,
      scoreB: data.scoreB,
      round: state.round
    });
    card.querySelector(`[data-role="scoreA"][data-court="${court.id}"]`).value = "";
    card.querySelector(`[data-role="scoreB"][data-court="${court.id}"]`).value = "";
  });
  saveState();
  toast("Matchs enregistrés");
});

btnEndSession.addEventListener("click", ()=>showPage("results"));
btnEditAssignments.addEventListener("click", ()=>showPage("assign"));
btnApplyRotation.addEventListener("click", ()=>{
  runAutoRotation();
});
btnNewRound.addEventListener("click", ()=>{
  state.round += 1;
  saveState();
  toast("Nouvelle rotation créée");
});
btnUndoLast.addEventListener("click", ()=>{
  if(state.matches.length===0) return toast("Aucun match");
  state.matches.pop();
  saveState();
  toast("Dernier match annulé");
});

if(btnToggleManualEdit){
  btnToggleManualEdit.addEventListener("click", ()=>{
    manualEditVisible = !manualEditVisible;
    renderManualAdjust();
  });
}
if(btnSaveManualAdjust){
  btnSaveManualAdjust.addEventListener("click", ()=>{
    if(!manualAdjustList){
      toast("Rien à enregistrer");
      return;
    }
    const result = collectAssignmentsFromContainer(manualAdjustList);
    if(!result) return;
    state.assignments = result;
    saveState();
    toast("Ajustements enregistrés");
    renderManualAdjust();
  });
}

function runAutoRotation(){
  const next = computeNextAssignments();
  if(!next) return false;
  state.assignments = next;
  state.round += 1;
  saveState();
  toast("Rotation suivante prête");
  return true;
}

function computeNextAssignments(){
  if(state.students.length===0 || state.courts.length===0){
    alert("Configure d’abord les élèves et terrains.");
    return null;
  }
  const roundToUse = state.round;
  const matches = state.matches.filter(m=>m.round===roundToUse);
  const latestByCourt = new Map();
  matches.forEach(m=>{
    const prev = latestByCourt.get(m.courtId);
    if(!prev || prev.ts < m.ts){
      latestByCourt.set(m.courtId, m);
    }
  });
  if(latestByCourt.size !== state.courts.length){
    alert("Enregistre les scores de tous les terrains avant d’appliquer la rotation.");
    return null;
  }
  const winners = [];
  const losers = [];
  state.courts.forEach((court, idx)=>{
    const match = latestByCourt.get(court.id);
    const aWin = match.scoreA >= match.scoreB;
    winners[idx] = (aWin ? match.teamA : match.teamB).slice();
    losers[idx]  = (aWin ? match.teamB : match.teamA).slice();
  });
  const used = new Set();
  const fallbackPool = state.students.map(s=>s.id);
  const next = {};

  const pickFallback = (blocked=new Set())=>{
    return fallbackPool.find(id=>!used.has(id) && !blocked.has(id));
  };

  const buildTeam = (primary, size, blocked=new Set(), extras=[])=>{
    const team = [];
    const localBlocked = new Set(blocked);
    const push = (id)=>{
      if(!id || used.has(id) || localBlocked.has(id)) return;
      team.push(id);
      used.add(id);
      localBlocked.add(id);
    };
    primary.forEach(push);
    if(team.length < size){
      extras.forEach(push);
    }
    while(team.length < size){
      const extra = pickFallback(localBlocked);
      if(!extra) break;
      push(extra);
    }
    return team.slice(0, size);
  };

  const totalCourts = state.courts.length;
  state.courts.forEach((court, idx)=>{
    const perTeam = (court.allowDoubles && court.mode==="D") ? 2 : 1;
    const hasLowerCourt = idx < totalCourts-1;
    let fromAbove = [];
    if(idx===0){
      fromAbove = (winners[0] || []).slice();
    }else{
      fromAbove = (losers[idx-1] || []).slice();
    }
    if(fromAbove.length===0){
      fromAbove = (getAssignment(court).teamA || []).slice();
    }
    let fromBelow = [];
    if(idx === totalCourts-1){
      fromBelow = (losers[idx] || []).slice();
    }else{
      fromBelow = (winners[idx+1] || []).slice();
    }
    if(fromBelow.length===0){
      fromBelow = (getAssignment(court).teamB || []).slice();
    }
    const prevAssign = getAssignment(court);
    const prevArb = prevAssign.umpire || null;
    let umpire = null;
    if(court.umpire){
      if(hasLowerCourt && fromBelow.length){
        umpire = fromBelow.shift();
      }else if(prevArb){
        umpire = prevArb;
      }else if(fromAbove.length){
        umpire = fromAbove.shift();
      }
      if(!umpire){
        const backup = pickFallback();
        if(backup){
          umpire = backup;
          used.add(backup);
        }
      }else{
        used.add(umpire);
      }
      if(prevArb && prevArb !== umpire){
        fromBelow.push(prevArb);
      }
    }
    const blockersA = new Set(umpire ? [umpire] : []);
    const teamA = buildTeam(fromAbove, perTeam, blockersA, prevAssign.teamA || []);
    const blockersB = new Set([...(umpire ? [umpire] : []), ...teamA]);
    const teamB = buildTeam(fromBelow, perTeam, blockersB, prevAssign.teamB || []);
    next[court.id] = {teamA, teamB, umpire};
  });
  return next;
}

/** ===== Résultats ===== */
const tblRankingBody = document.querySelector("#tblRanking tbody");
const playerModal = document.getElementById("playerModal");
const pmMatches = document.getElementById("pmMatches");
const pmChart = document.getElementById("pmChart");
const pmClose = document.getElementById("pmClose");

pmClose.addEventListener("click", ()=>playerModal.classList.remove("open"));
playerModal.addEventListener("click", (e)=>{
  if(e.target===playerModal) playerModal.classList.remove("open");
});

function computeRatings(){
  const rating = new Map();
  const history = new Map();
  const stats = new Map();
  state.students.forEach(s=>{
    rating.set(s.id, 1000);
    history.set(s.id, [{ts:0,r:1000}]);
    stats.set(s.id, {w:0,l:0,pf:0,pa:0});
  });
  const K = 24;
  const ordered = [...state.matches].sort((a,b)=>a.ts-b.ts);
  ordered.forEach(m=>{
    const ra = m.teamA.reduce((acc,id)=>acc + (rating.get(id)||1000),0)/m.teamA.length;
    const rb = m.teamB.reduce((acc,id)=>acc + (rating.get(id)||1000),0)/m.teamB.length;
    const expectedA = 1/(1+Math.pow(10,(rb-ra)/400));
    const expectedB = 1-expectedA;
    const aWin = m.scoreA > m.scoreB;
    const deltaA = Math.round(K*((aWin?1:0) - expectedA));
    const deltaB = Math.round(K*((aWin?0:1) - expectedB));
    m.teamA.forEach(id=>{
      rating.set(id, (rating.get(id)||1000) + deltaA);
      history.get(id).push({ts:m.ts, r:rating.get(id)});
      const st = stats.get(id);
      st.pf += m.scoreA; st.pa += m.scoreB;
      if(aWin) st.w += 1; else st.l += 1;
    });
    m.teamB.forEach(id=>{
      rating.set(id, (rating.get(id)||1000) + deltaB);
      history.get(id).push({ts:m.ts, r:rating.get(id)});
      const st = stats.get(id);
      st.pf += m.scoreB; st.pa += m.scoreA;
      if(!aWin) st.w += 1; else st.l += 1;
    });
  });
  return {rating, stats, history};
}

function renderResults(){
  if(!tblRankingBody) return;
  tblRankingBody.innerHTML = "";
  document.getElementById("kpiStudents").textContent = state.students.length;
  document.getElementById("kpiMatches").textContent = state.matches.length;
  document.getElementById("kpiCourts").textContent = state.courts.length;
  document.getElementById("kpiLast").textContent = state.matches.length ? new Date(state.matches[state.matches.length-1].ts).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"}) : "—";

  if(state.students.length===0){
    tblRankingBody.innerHTML = `<tr><td colspan="5" class="muted">Aucun élève. Va dans Saisie.</td></tr>`;
    return;
  }
  const {rating, stats} = computeRatings();
  const rows = state.students.map(s=>{
    const st = stats.get(s.id) || {w:0,l:0,pf:0,pa:0};
    return {
      id: s.id,
      name: s.name,
      perf: rating.get(s.id) || 1000,
      w: st.w,
      l: st.l,
      pf: st.pf,
      pa: st.pa
    };
  }).sort((a,b)=>b.perf - a.perf);

  rows.forEach((r, idx)=>{
    const tr = document.createElement("tr");
    tr.className = "clickRow";
    const diff = r.pf - r.pa;
    tr.innerHTML = `
      <td class="rank">${idx+1}</td>
      <td style="font-weight:900">${escapeHtml(r.name)}</td>
      <td class="rank">${r.perf}</td>
      <td class="rank">${r.pf} <span class="muted">(${diff>=0?"+":""}${diff})</span></td>
      <td>${r.w}</td>
      <td>${r.l}</td>
    `;
    tr.addEventListener("click", ()=>openPlayerModal(r));
    tblRankingBody.appendChild(tr);
  });
}

function openPlayerModal(row){
  const { rating, stats, history } = computeRatings();
  const stat = stats.get(row.id) || {w:0,l:0,pf:0,pa:0};
  document.getElementById("pmName").textContent = row.name;
  document.getElementById("pmSub").textContent = `${state.matches.length} match(s)`;
  const perf = rating.get(row.id) || row.perf;
  document.getElementById("pmPerf").textContent = perf;
  document.getElementById("pmVD").textContent = `${stat.w}-${stat.l}`;
  const diff = stat.pf - stat.pa;
  document.getElementById("pmPts").textContent = `${stat.pf}-${stat.pa} (${diff>=0?"+":""}${diff})`;
  const total = stat.w + stat.l;
  document.getElementById("pmRate").textContent = total ? `${Math.round((stat.w/total)*100)}%` : "—";
  const series = history.get(row.id) || [{ts:0,r:perf}];
  drawPlayerChart(series);

  const matches = state.matches.filter(m=>m.teamA.includes(row.id) || m.teamB.includes(row.id)).sort((a,b)=>b.ts-a.ts);
  if(matches.length===0){
    pmMatches.innerHTML = `<div class="muted">Aucun match pour cet élève.</div>`;
  }else{
    pmMatches.innerHTML = matches.map(m=>{
      const aNames = m.teamA.map(studentNameById).join(" + ");
      const bNames = m.teamB.map(studentNameById).join(" + ");
      const isA = m.teamA.includes(row.id);
      const myScore = isA ? m.scoreA : m.scoreB;
      const opScore = isA ? m.scoreB : m.scoreA;
      const win = myScore > opScore;
      const courtName = state.courts.find(c=>c.id===m.courtId)?.name || "Terrain";
      return `
        <div class="court modalMatch">
          <div class="courtTop">
            <div class="name">${escapeHtml(courtName)}</div>
            <span class="tag">Rot. ${m.round}</span>
            <span class="tag">${m.mode==="D"?"Double":"Simple"}</span>
          </div>
          <div>${escapeHtml(aNames)} vs ${escapeHtml(bNames)}</div>
          <div class="hint" style="margin-top:6px">${win?"Victoire":"Défaite"} — ${myScore}-${opScore}</div>
        </div>`;
    }).join("");
  }
  playerModal.classList.add("open");
}

function drawPlayerChart(series){
  if(!pmChart) return;
  const ctx = pmChart.getContext("2d");
  const W = pmChart.width;
  const H = pmChart.height;
  ctx.clearRect(0,0,W,H);
  if(!series.length){
    ctx.fillStyle = "#fff";
    ctx.font = "14px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText("Pas de données", 10, H/2);
    return;
  }
  const values = series.map(p=>p.r);
  const min = Math.min(...values, 900);
  const max = Math.max(...values, 1100);
  const pad = 30;
  ctx.strokeStyle = "rgba(255,255,255,.25)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad, pad);
  ctx.lineTo(pad, H-pad);
  ctx.lineTo(W-pad, H-pad);
  ctx.stroke();
  const toX = idx => pad + (W - pad*2) * (idx/(Math.max(1, series.length-1)));
  const toY = val => {
    if(max===min) return H/2;
    return pad + (H - pad*2) * (1 - (val - min)/(max - min));
  };
  ctx.strokeStyle = "#66e3ff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  series.forEach((point, idx)=>{
    const x = toX(idx);
    const y = toY(point.r);
    if(idx===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  });
  ctx.stroke();
  ctx.fillStyle = "#9bff8a";
  series.forEach((point, idx)=>{
    const x = toX(idx);
    const y = toY(point.r);
    ctx.beginPath();
    ctx.arc(x,y,4,0,Math.PI*2);
    ctx.fill();
  });
}

/** ===== Export simple ===== */
document.getElementById("btnExport").addEventListener("click", ()=>{
  if(state.students.length===0){
    alert("Aucun élève");
    return;
  }
  const { rating, stats } = computeRatings();
  const studentsRows = [["tournament","student_id","nom","perf"]];
  state.students.forEach(s=>{
    studentsRows.push([state.tournamentName, s.id, s.name, rating.get(s.id) || 1000]);
  });
  downloadCSV("eleves.csv", studentsRows);

  const matchesRows = [["tournament","match_id","timestamp","round","court","mode","umpire","teamA","teamB","scoreA","scoreB"]];
  state.matches.forEach(m=>{
    const courtName = state.courts.find(c=>c.id===m.courtId)?.name || "";
    const teamA = m.teamA.map(studentNameById).join(" + ");
    const teamB = m.teamB.map(studentNameById).join(" + ");
    matchesRows.push([
      state.tournamentName,
      m.id,
      new Date(m.ts).toISOString(),
      m.round,
      courtName,
      m.mode==="D" ? "double" : "simple",
      m.umpire ? "avec arbitre" : "sans arbitre",
      teamA,
      teamB,
      m.scoreA,
      m.scoreB
    ]);
  });
  downloadCSV("matchs.csv", matchesRows);

  const bilanRows = [["tournament","student_id","nom","perf","wins","losses","points_for","points_against","diff"]];
  state.students.forEach(s=>{
    const st = stats.get(s.id) || {w:0,l:0,pf:0,pa:0};
    bilanRows.push([
      state.tournamentName,
      s.id,
      s.name,
      rating.get(s.id) || 1000,
      st.w,
      st.l,
      st.pf,
      st.pa,
      st.pf - st.pa
    ]);
  });
  downloadCSV("bilan.csv", bilanRows);
  toast("CSV exportés");
});
function downloadCSV(filename, rows){
  const csv = rows.map(r=>r.map(csvEscape).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  setTimeout(()=>{
    URL.revokeObjectURL(link.href);
    link.remove();
  }, 0);
}

function csvEscape(value){
  const str = String(value ?? "");
  if(/[",\n]/.test(str)){
    return `"${str.replace(/"/g,'""')}"`;
  }
  return str;
}

/** ===== NAV + Modes ===== */
const navButtons = document.querySelectorAll(".navBtn");
navButtons.forEach(btn=>{
  btn.addEventListener("click", ()=>{
    navButtons.forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    showPage(btn.dataset.nav);
  });
});

function showPage(name){
  ["home","setup","assign","matches","results"].forEach(p=>{
    document.getElementById(`page-${p}`).style.display = (p===name)?"":"none";
  });
  navButtons.forEach(btn=>{
    btn.classList.toggle("active", btn.dataset.nav===name);
  });
  renderAll();
}

document.getElementById("btnStart").addEventListener("click", ()=>showPage("setup"));
document.getElementById("btnEndSession").addEventListener("click", ()=>showPage("results"));

document.getElementById("btnResetAll").addEventListener("click", ()=>{
  if(confirm("Effacer toutes les données ?")){
    state = defaultState();
    setupPreview = [];
    saveState();
    toast("Données réinitialisées");
    showPage("setup");
  }
});

document.getElementById("btnInstallTip").addEventListener("click", ()=>{
  alert("iPad : Safari → Partager → “Sur l’écran d’accueil”. L’application fonctionne hors-ligne.");
});

/** ===== Render ===== */
function escapeHtml(str){
  return (str ?? "").replace(/[&<>"']/g, ch=>({
    "&":"&amp;",
    "<":"&lt;",
    ">":"&gt;",
    '"':"&quot;",
    "'":"&#039;"
  }[ch] || ch));
}

function renderAll(){
  inpTournament.value = state.tournamentName || "Évaluation Bac";
  tournamentNameEl.textContent = state.tournamentName || "Évaluation Bac";
  taStudents.value = state.students.map(s=>s.name).join("\n");
  if(state.courts.length){
    inpCourts.value = state.courts.length;
  }
  renderTimer();
  if(document.getElementById("page-setup").style.display !== "none"){
    renderCourtConfig();
  }
  if(document.getElementById("page-assign").style.display !== "none"){
    renderAssignmentsPage();
  }
  if(document.getElementById("page-matches").style.display !== "none"){
    renderCourtsLive();
    renderManualAdjust();
  }
  if(document.getElementById("page-results").style.display !== "none"){
    renderResults();
  }
}

renderAll();
</script>
</body>
</html>
